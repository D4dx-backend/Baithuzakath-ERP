const mongoose = require('mongoose');

const donationSchema = new mongoose.Schema({
  // Basic Information
  donationNumber: {
    type: String,
    unique: true
    // Will be auto-generated by pre-save middleware
  },
  
  // References (optional for anonymous donations)
  donor: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Donor',
    default: null // Allow null for anonymous donations
  },
  project: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Project',
    default: null
  },
  scheme: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Scheme',
    default: null
  },
  
  // Donation Details
  amount: {
    type: Number,
    required: [true, 'Donation amount is required'],
    min: [0, 'Donation amount cannot be negative']
  },
  currency: {
    type: String,
    default: 'INR'
  },
  
  // Payment Method
  method: {
    type: String,
    enum: ['online', 'bank_transfer', 'cash', 'cheque', 'card', 'upi', 'digital_wallet'],
    required: [true, 'Payment method is required']
  },
  
  // Anonymous Donor Information (for anonymous donations)
  anonymousDonor: {
    name: String,
    email: String,
    phone: String,
    address: {
      street: String,
      city: String,
      state: String,
      pincode: String,
      country: {
        type: String,
        default: 'India'
      }
    }
  },
  
  // Payment Details based on method
  paymentDetails: {
    // Bank Transfer Details
    bankTransfer: {
      transactionId: String,
      utrNumber: String,
      bankName: String,
      accountNumber: String,
      ifscCode: String,
      transferDate: Date
    },
    
    // Online Payment Details
    online: {
      gateway: {
        type: String,
        enum: ['razorpay', 'payu', 'ccavenue', 'instamojo', 'stripe', 'other']
      },
      transactionId: String,
      paymentId: String,
      orderId: String,
      signature: String,
      status: String
    },
    
    // Card Payment Details
    card: {
      last4Digits: String,
      cardType: {
        type: String,
        enum: ['credit', 'debit']
      },
      bankName: String,
      transactionId: String
    },
    
    // UPI Details
    upi: {
      upiId: String,
      transactionId: String,
      provider: String
    },
    
    // Cheque Details
    cheque: {
      chequeNumber: String,
      bankName: String,
      branchName: String,
      issueDate: Date,
      clearanceDate: Date,
      status: {
        type: String,
        enum: ['issued', 'deposited', 'cleared', 'bounced', 'cancelled'],
        default: 'issued'
      }
    },
    
    // Cash Details
    cash: {
      receivedBy: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User'
      },
      receiptNumber: String,
      location: String,
      receivedDate: {
        type: Date,
        default: Date.now
      }
    }
  },
  
  // Status and Timeline
  status: {
    type: String,
    enum: ['pending', 'processing', 'completed', 'failed', 'cancelled', 'refunded'],
    default: 'pending'
  },
  
  timeline: {
    createdAt: {
      type: Date,
      default: Date.now
    },
    processingAt: Date,
    completedAt: Date,
    failedAt: Date,
    cancelledAt: Date,
    refundedAt: Date
  },
  
  // Tax and Receipt Information
  tax: {
    panRequired: {
      type: Boolean,
      default: false
    },
    panNumber: String,
    exemptionCertificate: {
      required: Boolean,
      certificateNumber: String,
      issuedBy: String,
      validUntil: Date
    },
    taxDeducted: {
      type: Number,
      default: 0
    },
    taxRate: {
      type: Number,
      default: 0
    }
  },
  
  receipt: {
    receiptNumber: String,
    issuedDate: Date,
    downloadUrl: String,
    emailSent: {
      type: Boolean,
      default: false
    },
    emailSentAt: Date
  },
  
  // Donation Purpose and Preferences
  purpose: {
    type: String,
    enum: ['general', 'education', 'healthcare', 'emergency_relief', 'infrastructure', 'food_security', 'other'],
    default: 'general'
  },
  
  preferences: {
    isRecurring: {
      type: Boolean,
      default: false
    },
    frequency: {
      type: String,
      enum: ['one-time', 'monthly', 'quarterly', 'yearly'],
      default: 'one-time'
    },
    nextDonationDate: Date,
    endDate: Date,
    isAnonymous: {
      type: Boolean,
      default: false
    },
    publicDisplay: {
      type: Boolean,
      default: true
    }
  },
  
  // Campaign and Source Tracking
  campaign: {
    campaignId: String,
    campaignName: String,
    source: {
      type: String,
      enum: ['website', 'mobile_app', 'social_media', 'email', 'sms', 'offline', 'referral', 'other'],
      default: 'website'
    },
    medium: String,
    referrer: String,
    utmParams: {
      source: String,
      medium: String,
      campaign: String,
      term: String,
      content: String
    }
  },
  
  // Verification and Compliance
  verification: {
    status: {
      type: String,
      enum: ['pending', 'verified', 'rejected'],
      default: 'pending'
    },
    verifiedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    verifiedAt: Date,
    notes: String,
    documents: [{
      type: String,
      url: String,
      uploadedAt: {
        type: Date,
        default: Date.now
      }
    }]
  },
  
  // Failure Information
  failure: {
    reason: String,
    errorCode: String,
    errorMessage: String,
    retryCount: {
      type: Number,
      default: 0
    },
    canRetry: {
      type: Boolean,
      default: true
    }
  },
  
  // Refund Information
  refund: {
    reason: String,
    refundAmount: Number,
    refundMethod: String,
    refundDate: Date,
    refundTransactionId: String,
    refundedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    refundStatus: {
      type: String,
      enum: ['initiated', 'processing', 'completed', 'failed']
    }
  },
  
  // Communication and Notifications
  notifications: [{
    type: {
      type: String,
      enum: ['sms', 'email', 'push', 'whatsapp']
    },
    recipient: String,
    message: String,
    status: {
      type: String,
      enum: ['pending', 'sent', 'delivered', 'failed']
    },
    sentAt: Date,
    deliveredAt: Date
  }],
  
  // Audit Trail
  createdBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  processedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  lastModifiedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  
  // Additional Information
  notes: String,
  internalNotes: String, // For staff use only
  tags: [String],
  metadata: {
    ipAddress: String,
    userAgent: String,
    deviceInfo: String,
    location: {
      country: String,
      state: String,
      city: String,
      coordinates: {
        latitude: Number,
        longitude: Number
      }
    }
  }
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Indexes
donationSchema.index({ donationNumber: 1 });
donationSchema.index({ donor: 1 });
donationSchema.index({ project: 1, scheme: 1 });
donationSchema.index({ status: 1 });
donationSchema.index({ method: 1 });
donationSchema.index({ 'timeline.createdAt': 1 });
donationSchema.index({ 'paymentDetails.online.transactionId': 1 });
donationSchema.index({ 'paymentDetails.bankTransfer.transactionId': 1 });
donationSchema.index({ 'paymentDetails.cheque.chequeNumber': 1 });
donationSchema.index({ 'campaign.campaignId': 1 });
donationSchema.index({ 'verification.status': 1 });
donationSchema.index({ 'preferences.isRecurring': 1 });

// Virtual for donor name (handles anonymous donations)
donationSchema.virtual('donorName').get(function() {
  if (this.donor && this.donor.name) {
    return this.preferences.isAnonymous ? 'Anonymous' : this.donor.name;
  }
  if (this.anonymousDonor && this.anonymousDonor.name) {
    return this.preferences.isAnonymous ? 'Anonymous' : this.anonymousDonor.name;
  }
  return 'Anonymous';
});

// Virtual for net donation amount (after tax deductions)
donationSchema.virtual('netAmount').get(function() {
  return this.amount - (this.tax.taxDeducted || 0);
});

// Pre-save middleware to generate donation number
donationSchema.pre('save', async function(next) {
  if (this.isNew && !this.donationNumber) {
    try {
      const year = new Date().getFullYear();
      const month = String(new Date().getMonth() + 1).padStart(2, '0');
      
      // Count donations for current month
      const count = await this.constructor.countDocuments({
        createdAt: {
          $gte: new Date(year, new Date().getMonth(), 1),
          $lt: new Date(year, new Date().getMonth() + 1, 1)
        }
      });
      
      // Format: DON_YYYY_MM_SEQUENCE
      const sequence = String(count + 1).padStart(5, '0');
      this.donationNumber = `DON_${year}_${month}_${sequence}`;
      
      next();
    } catch (error) {
      next(error);
    }
  } else {
    next();
  }
});

// Pre-save middleware to update timeline
donationSchema.pre('save', function(next) {
  const now = new Date();
  
  // Update timeline based on status changes
  if (this.isModified('status')) {
    switch (this.status) {
      case 'processing':
        if (!this.timeline.processingAt) {
          this.timeline.processingAt = now;
        }
        break;
      case 'completed':
        if (!this.timeline.completedAt) {
          this.timeline.completedAt = now;
        }
        break;
      case 'failed':
        if (!this.timeline.failedAt) {
          this.timeline.failedAt = now;
        }
        break;
      case 'cancelled':
        if (!this.timeline.cancelledAt) {
          this.timeline.cancelledAt = now;
        }
        break;
      case 'refunded':
        if (!this.timeline.refundedAt) {
          this.timeline.refundedAt = now;
        }
        break;
    }
  }
  
  next();
});

// Method to complete donation
donationSchema.methods.complete = function(transactionDetails = {}) {
  this.status = 'completed';
  this.timeline.completedAt = new Date();
  
  // Update payment details based on method
  if (transactionDetails.transactionId) {
    if (this.method === 'online') {
      this.paymentDetails.online.transactionId = transactionDetails.transactionId;
      this.paymentDetails.online.status = 'success';
    } else if (this.method === 'bank_transfer') {
      this.paymentDetails.bankTransfer.transactionId = transactionDetails.transactionId;
      this.paymentDetails.bankTransfer.utrNumber = transactionDetails.utrNumber;
    }
  }
  
  // Mark as verified for completed donations
  this.verification.status = 'verified';
  this.verification.verifiedAt = new Date();
  
  return this.save();
};

// Method to fail donation
donationSchema.methods.fail = function(reason, errorCode, errorMessage) {
  this.status = 'failed';
  this.timeline.failedAt = new Date();
  
  this.failure.reason = reason;
  this.failure.errorCode = errorCode;
  this.failure.errorMessage = errorMessage;
  this.failure.retryCount++;
  
  return this.save();
};

// Method to process refund
donationSchema.methods.processRefund = function(reason, refundAmount, refundedBy) {
  this.status = 'refunded';
  this.timeline.refundedAt = new Date();
  
  this.refund.reason = reason;
  this.refund.refundAmount = refundAmount || this.amount;
  this.refund.refundedBy = refundedBy;
  this.refund.refundDate = new Date();
  this.refund.refundStatus = 'initiated';
  
  return this.save();
};

// Static method to get donations by donor
donationSchema.statics.getByDonor = function(donorId, filters = {}) {
  return this.find({ donor: donorId, ...filters })
    .populate('project', 'name code')
    .populate('scheme', 'name code')
    .sort({ 'timeline.createdAt': -1 });
};

// Static method to get donations by status
donationSchema.statics.getByStatus = function(status, filters = {}) {
  return this.find({ status, ...filters })
    .populate('donor', 'name email phone')
    .populate('project', 'name code')
    .populate('scheme', 'name code')
    .sort({ 'timeline.createdAt': -1 });
};

// Static method to get recent donations
donationSchema.statics.getRecent = function(limit = 20, filters = {}) {
  return this.find(filters)
    .populate('donor', 'name email phone type category')
    .populate('project', 'name code')
    .populate('scheme', 'name code')
    .sort({ 'timeline.createdAt': -1 })
    .limit(limit);
};

// Static method to get donation statistics
donationSchema.statics.getStats = function(filters = {}) {
  return this.aggregate([
    { $match: { status: 'completed', ...filters } },
    {
      $group: {
        _id: null,
        totalAmount: { $sum: '$amount' },
        totalDonations: { $sum: 1 },
        averageDonation: { $avg: '$amount' },
        uniqueDonors: { $addToSet: '$donor' }
      }
    },
    {
      $addFields: {
        uniqueDonorCount: { $size: '$uniqueDonors' }
      }
    }
  ]);
};

module.exports = mongoose.model('Donation', donationSchema);